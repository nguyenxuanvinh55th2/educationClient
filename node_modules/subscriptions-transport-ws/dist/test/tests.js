"use strict";
require('mocha');
var chai_1 = require('chai');
var sinon = require('sinon');
var graphql_1 = require('graphql');
var graphql_subscriptions_1 = require('graphql-subscriptions');
var messageTypes_1 = require('../messageTypes');
var protocols_1 = require('../protocols');
var http_1 = require('http');
var server_1 = require('../server');
var client_1 = require('../client');
var websocket_1 = require('websocket');
var websocket = require('websocket');
var W3CWebSocket = websocket['w3cwebsocket'];
var TEST_PORT = 4953;
var KEEP_ALIVE_TEST_PORT = TEST_PORT + 1;
var DELAYED_TEST_PORT = TEST_PORT + 2;
var RAW_TEST_PORT = TEST_PORT + 4;
var data = {
    '1': {
        'id': '1',
        'name': 'Dan',
    },
    '2': {
        'id': '2',
        'name': 'Marie',
    },
    '3': {
        'id': '3',
        'name': 'Jessie',
    },
};
var userType = new graphql_1.GraphQLObjectType({
    name: 'User',
    fields: {
        id: { type: graphql_1.GraphQLString },
        name: { type: graphql_1.GraphQLString },
    },
});
var schema = new graphql_1.GraphQLSchema({
    query: new graphql_1.GraphQLObjectType({
        name: 'Query',
        fields: {
            testString: { type: graphql_1.GraphQLString },
        },
    }),
    subscription: new graphql_1.GraphQLObjectType({
        name: 'Subscription',
        fields: {
            user: {
                type: userType,
                args: {
                    id: { type: graphql_1.GraphQLString },
                },
                resolve: function (_, _a) {
                    var id = _a.id;
                    return data[id];
                },
            },
            userFiltered: {
                type: userType,
                args: {
                    id: { type: graphql_1.GraphQLString },
                },
                resolve: function (_, _a) {
                    var id = _a.id;
                    return data[id];
                },
            },
            context: {
                type: graphql_1.GraphQLString,
                resolve: function (root, args, ctx) {
                    return ctx;
                },
            },
            error: { type: graphql_1.GraphQLString, resolve: function () { throw new Error('E1'); } },
        },
    }),
});
var subscriptionManager = new graphql_subscriptions_1.SubscriptionManager({
    schema: schema,
    pubsub: new graphql_subscriptions_1.PubSub(),
    setupFunctions: {
        'userFiltered': function (options, args) { return ({
            'userFiltered': {
                filter: function (user) {
                    return !args['id'] || user.id === args['id'];
                },
            },
        }); },
    },
});
var handlers = {
    onSubscribe: function (msg, params, webSocketRequest) {
        return Promise.resolve(Object.assign({}, params, { context: msg['context'] }));
    },
};
var options = {
    subscriptionManager: subscriptionManager,
    onSubscribe: function (msg, params, webSocketRequest) {
        return handlers.onSubscribe(msg, params, webSocketRequest);
    },
};
function notFoundRequestListener(request, response) {
    response.writeHead(404);
    response.end();
}
var httpServer = http_1.createServer(notFoundRequestListener);
httpServer.listen(TEST_PORT);
new server_1.default(options, httpServer);
var httpServerWithKA = http_1.createServer(notFoundRequestListener);
httpServerWithKA.listen(KEEP_ALIVE_TEST_PORT);
new server_1.default(Object.assign({}, options, { keepAlive: 10 }), httpServerWithKA);
var httpServerWithDelay = http_1.createServer(notFoundRequestListener);
httpServerWithDelay.listen(DELAYED_TEST_PORT);
new server_1.default(Object.assign({}, options, {
    onSubscribe: function (msg, params) {
        return new Promise(function (resolve, reject) {
            setTimeout(function () {
                resolve(Object.assign({}, params, { context: msg['context'] }));
            }, 100);
        });
    },
}), httpServerWithDelay);
var httpServerRaw = http_1.createServer(notFoundRequestListener);
httpServerRaw.listen(RAW_TEST_PORT);
describe('Client', function () {
    var wsServer;
    beforeEach(function () {
        wsServer = new websocket_1.server({
            httpServer: httpServerRaw,
            autoAcceptConnections: true,
        });
    });
    afterEach(function () {
        if (wsServer) {
            wsServer.shutDown();
        }
    });
    it('removes subscription when it unsubscribes from it', function () {
        var client = new client_1.default("ws://localhost:" + TEST_PORT + "/");
        setTimeout(function () {
            var subId = client.subscribe({
                query: "subscription useInfo($id: String) {\n          user(id: $id) {\n            id\n            name\n          }\n        }",
                operationName: 'useInfo',
                variables: {
                    id: 3,
                },
            }, function (error, result) {
            });
            client.unsubscribe(subId);
            chai_1.assert.notProperty(client.subscriptions, "" + subId);
        }, 100);
    });
    it('queues messages while websocket is still connecting', function () {
        var client = new client_1.default("ws://localhost:" + TEST_PORT + "/");
        var subId = client.subscribe({
            query: "subscription useInfo($id: String) {\n        user(id: $id) {\n          id\n          name\n        }\n      }",
            operationName: 'useInfo',
            variables: {
                id: 3,
            },
        }, function (error, result) {
        });
        chai_1.expect(client.unsentMessagesQueue.length).to.equals(1);
        client.unsubscribe(subId);
        chai_1.expect(client.unsentMessagesQueue.length).to.equals(2);
        setTimeout(function () {
            chai_1.expect(client.unsentMessagesQueue.length).to.equals(0);
        }, 100);
    });
    it('should call error handler when graphql result has errors', function (done) {
        var client = new client_1.default("ws://localhost:" + TEST_PORT + "/");
        setTimeout(function () {
            client.subscribe({
                query: "subscription useInfo{\n          error\n        }",
                variables: {},
            }, function (error, result) {
                if (error) {
                    client.unsubscribeAll();
                    done();
                }
                if (result) {
                    client.unsubscribeAll();
                    chai_1.assert(false);
                }
            });
        }, 100);
        setTimeout(function () {
            subscriptionManager.publish('error', {});
        }, 200);
    });
    it('should call error handler when graphql query is not valid', function (done) {
        var client = new client_1.default("ws://localhost:" + TEST_PORT + "/");
        setTimeout(function () {
            client.subscribe({
                query: "subscription useInfo{\n          invalid\n        }",
                variables: {},
            }, function (error, result) {
                if (error) {
                    chai_1.expect(error[0].message).to.equals('Cannot query field "invalid" on type "Subscription".');
                    done();
                }
                else {
                    chai_1.assert(false);
                }
            });
        }, 100);
    });
    function testBadServer(payload, errorMessage, done) {
        wsServer.on('connect', function (connection) {
            connection.on('message', function (message) {
                var parsedMessage = JSON.parse(message.utf8Data);
                if (parsedMessage.type === messageTypes_1.SUBSCRIPTION_START) {
                    connection.sendUTF(JSON.stringify({
                        type: messageTypes_1.SUBSCRIPTION_FAIL,
                        id: parsedMessage.id,
                        payload: payload,
                    }));
                }
            });
        });
        var client = new client_1.default("ws://localhost:" + RAW_TEST_PORT + "/");
        client.subscribe({
            query: "\n        subscription useInfo{\n          invalid\n        }\n      ",
            variables: {},
        }, function (errors, result) {
            if (errors) {
                chai_1.expect(errors[0].message).to.equals(errorMessage);
            }
            else {
                chai_1.assert(false);
            }
            done();
        });
    }
    it('should handle missing errors', function (done) {
        var errorMessage = 'Unknown error';
        var payload = {};
        testBadServer(payload, errorMessage, done);
    });
    it('should handle errors that are not an array', function (done) {
        var errorMessage = 'Just an error';
        var payload = {
            errors: { message: errorMessage },
        };
        testBadServer(payload, errorMessage, done);
    });
    it('should throw an error when the susbcription times out', function (done) {
        var client = new client_1.default("ws://localhost:" + DELAYED_TEST_PORT + "/", { timeout: 1 });
        setTimeout(function () {
            client.subscribe({
                query: "subscription useInfo{\n            error\n          }",
                operationName: 'useInfo',
                variables: {},
            }, function (error, result) {
                if (error) {
                    chai_1.expect(error[0].message).to.equals('Subscription timed out - no response from server');
                    done();
                }
                if (result) {
                    chai_1.assert(false);
                }
            });
        }, 100);
    });
    it('should reconnect to the server', function (done) {
        var connections = 0;
        var client;
        var originalClient;
        wsServer.on('connect', function (connection) {
            connections += 1;
            if (connections === 1) {
                wsServer.closeAllConnections();
            }
            else {
                chai_1.expect(client.client).to.not.be.equal(originalClient);
                done();
            }
        });
        client = new client_1.default("ws://localhost:" + RAW_TEST_PORT + "/", { reconnect: true });
        originalClient = client.client;
    });
    it('should resubscribe after reconnect', function (done) {
        var connections = 0;
        wsServer.on('connect', function (connection) {
            connections += 1;
            connection.on('message', function (message) {
                var parsedMessage = JSON.parse(message.utf8Data);
                if (parsedMessage.type === messageTypes_1.SUBSCRIPTION_START) {
                    if (connections === 1) {
                        wsServer.closeAllConnections();
                    }
                    else {
                        done();
                    }
                }
            });
        });
        var client = new client_1.default("ws://localhost:" + RAW_TEST_PORT + "/", { reconnect: true });
        client.subscribe({
            query: "\n        subscription useInfo{\n          invalid\n        }\n      ",
            variables: {},
        }, function (errors, result) {
            chai_1.assert(false);
        });
    });
    it('should stop trying to reconnect to the server', function (done) {
        var connections = 0;
        wsServer.on('connect', function (connection) {
            connections += 1;
            if (connections === 1) {
                wsServer.unmount();
                wsServer.closeAllConnections();
            }
            else {
                chai_1.assert(false);
            }
        });
        var client = new client_1.default("ws://localhost:" + RAW_TEST_PORT + "/", {
            timeout: 100,
            reconnect: true,
            reconnectionAttempts: 1,
        });
        setTimeout(function () {
            chai_1.expect(client.client.readyState).to.be.equal(client.client.CLOSED);
            done();
        }, 500);
    });
});
describe('Server', function () {
    var onSubscribeSpy;
    beforeEach(function () {
        onSubscribeSpy = sinon.spy(handlers, 'onSubscribe');
    });
    afterEach(function () {
        onSubscribeSpy.restore();
    });
    it('should send correct results to multiple clients with subscriptions', function (done) {
        var client = new client_1.default("ws://localhost:" + TEST_PORT + "/");
        var client1 = new client_1.default("ws://localhost:" + TEST_PORT + "/");
        var numResults = 0;
        setTimeout(function () {
            client.subscribe({
                query: "subscription useInfo($id: String) {\n          user(id: $id) {\n            id\n            name\n          }\n        }",
                operationName: 'useInfo',
                variables: {
                    id: 3,
                },
            }, function (error, result) {
                if (error) {
                    chai_1.assert(false);
                }
                if (result) {
                    chai_1.assert.property(result, 'user');
                    chai_1.assert.equal(result.user.id, '3');
                    chai_1.assert.equal(result.user.name, 'Jessie');
                    numResults++;
                }
                else {
                }
            });
        }, 100);
        var client11 = new client_1.default("ws://localhost:" + TEST_PORT + "/");
        var numResults1 = 0;
        setTimeout(function () {
            client11.subscribe({
                query: "subscription useInfo($id: String) {\n          user(id: $id) {\n            id\n            name\n          }\n        }",
                operationName: 'useInfo',
                variables: {
                    id: 2,
                },
            }, function (error, result) {
                if (error) {
                    chai_1.assert(false);
                }
                if (result) {
                    chai_1.assert.property(result, 'user');
                    chai_1.assert.equal(result.user.id, '2');
                    chai_1.assert.equal(result.user.name, 'Marie');
                    numResults1++;
                }
            });
        }, 100);
        setTimeout(function () {
            subscriptionManager.publish('user', {});
        }, 200);
        setTimeout(function () {
            client.unsubscribeAll();
            chai_1.expect(numResults).to.equals(1);
            client1.unsubscribeAll();
            chai_1.expect(numResults1).to.equals(1);
            done();
        }, 300);
    });
    it('should send a subscription_fail message to client with invalid query', function (done) {
        var client1 = new client_1.default("ws://localhost:" + TEST_PORT + "/");
        setTimeout(function () {
            client1.client.onmessage = function (message) {
                var messageData = JSON.parse(message.data);
                chai_1.assert.equal(messageData.type, messageTypes_1.SUBSCRIPTION_FAIL);
                chai_1.assert.isAbove(messageData.payload.errors.length, 0, 'Number of errors is greater than 0.');
                done();
            };
            client1.subscribe({
                query: "subscription useInfo($id: String) {\n          user(id: $id) {\n            id\n            birthday\n          }\n        }",
                operationName: 'useInfo',
                variables: {
                    id: 3,
                },
            }, function (error, result) {
            });
        }, 100);
    });
    it('should set up the proper filters when subscribing', function (done) {
        var numTriggers = 0;
        var client3 = new client_1.default("ws://localhost:" + TEST_PORT + "/");
        var client4 = new client_1.default("ws://localhost:" + TEST_PORT + "/");
        setTimeout(function () {
            client3.subscribe({
                query: "subscription userInfoFilter1($id: String) {\n            userFiltered(id: $id) {\n              id\n              name\n            }\n          }",
                operationName: 'userInfoFilter1',
                variables: {
                    id: 3,
                },
            }, function (error, result) {
                if (error) {
                    chai_1.assert(false);
                }
                if (result) {
                    numTriggers += 1;
                    chai_1.assert.property(result, 'userFiltered');
                    chai_1.assert.equal(result.userFiltered.id, '3');
                    chai_1.assert.equal(result.userFiltered.name, 'Jessie');
                }
            });
            client4.subscribe({
                query: "subscription userInfoFilter1($id: String) {\n            userFiltered(id: $id) {\n              id\n              name\n            }\n          }",
                operationName: 'userInfoFilter1',
                variables: {
                    id: 1,
                },
            }, function (error, result) {
                if (result) {
                    numTriggers += 1;
                    chai_1.assert.property(result, 'userFiltered');
                    chai_1.assert.equal(result.userFiltered.id, '1');
                    chai_1.assert.equal(result.userFiltered.name, 'Dan');
                }
                if (error) {
                    chai_1.assert(false);
                }
            });
        }, 100);
        setTimeout(function () {
            subscriptionManager.publish('userFiltered', { id: 1 });
            subscriptionManager.publish('userFiltered', { id: 2 });
            subscriptionManager.publish('userFiltered', { id: 3 });
        }, 200);
        setTimeout(function () {
            chai_1.assert.equal(numTriggers, 2);
            done();
        }, 300);
    });
    it('correctly sets the context in onSubscribe', function (done) {
        var CTX = 'testContext';
        var client3 = new client_1.default("ws://localhost:" + TEST_PORT + "/");
        client3.subscribe({
            query: "subscription context {\n          context\n        }",
            variables: {},
            context: CTX,
        }, function (error, result) {
            if (error) {
                chai_1.assert(false);
            }
            if (result) {
                chai_1.assert.property(result, 'context');
                chai_1.assert.equal(result.context, CTX);
            }
            done();
        });
        setTimeout(function () {
            subscriptionManager.publish('context', {});
        }, 100);
    });
    it('passes through webSocketRequest to onSubscribe', function (done) {
        var client = new client_1.default("ws://localhost:" + TEST_PORT + "/");
        client.subscribe({
            query: "\n        subscription context {\n          context\n        }\n      ",
            variables: {},
        }, function (error, result) {
            chai_1.assert(false);
        });
        setTimeout(function () {
            chai_1.assert(onSubscribeSpy.calledOnce);
            chai_1.expect(onSubscribeSpy.getCall(0).args[2]).to.not.be.undefined;
            done();
        }, 100);
    });
    it('does not send more subscription data after client unsubscribes', function () {
        var client4 = new client_1.default("ws://localhost:" + TEST_PORT + "/");
        setTimeout(function () {
            var subId = client4.subscribe({
                query: "subscription useInfo($id: String) {\n          user(id: $id) {\n            id\n            name\n          }\n        }",
                operationName: 'useInfo',
                variables: {
                    id: 3,
                },
            }, function (error, result) {
            });
            client4.unsubscribe(subId);
        }, 100);
        setTimeout(function () {
            subscriptionManager.publish('user', {});
        }, 200);
        client4.client.onmessage = function (message) {
            if (JSON.parse(message.data).type === messageTypes_1.SUBSCRIPTION_DATA) {
                chai_1.assert(false);
            }
        };
    });
    it('rejects a client that does not specify a supported protocol', function (done) {
        var client = new W3CWebSocket("ws://localhost:" + TEST_PORT + "/");
        client.onerror = function (message) {
            done();
        };
    });
    it('rejects unparsable message', function (done) {
        var client = new W3CWebSocket("ws://localhost:" + TEST_PORT + "/", protocols_1.GRAPHQL_SUBSCRIPTIONS);
        client.onmessage = function (message) {
            var messageData = JSON.parse(message.data);
            chai_1.assert.equal(messageData.type, messageTypes_1.SUBSCRIPTION_FAIL);
            chai_1.assert.isAbove(messageData.payload.errors.length, 0, 'Number of errors is greater than 0.');
            client.close();
            done();
        };
        client.onopen = function () {
            client.send('HI');
        };
    });
    it('rejects nonsense message', function (done) {
        var client = new W3CWebSocket("ws://localhost:" + TEST_PORT + "/", protocols_1.GRAPHQL_SUBSCRIPTIONS);
        client.onmessage = function (message) {
            var messageData = JSON.parse(message.data);
            chai_1.assert.equal(messageData.type, messageTypes_1.SUBSCRIPTION_FAIL);
            chai_1.assert.isAbove(messageData.payload.errors.length, 0, 'Number of errors is greater than 0.');
            client.close();
            done();
        };
        client.onopen = function () {
            client.send(JSON.stringify({}));
        };
    });
    it('sends back any type of error', function (done) {
        var client = new client_1.default("ws://localhost:" + TEST_PORT + "/");
        client.subscribe({
            query: "invalid useInfo{\n          error\n        }",
            variables: {},
        }, function (errors, result) {
            client.unsubscribeAll();
            chai_1.assert.isAbove(errors.length, 0, 'Number of errors is greater than 0.');
            done();
        });
    });
    it('sends a keep alive signal in the socket', function (done) {
        var client = new W3CWebSocket("ws://localhost:" + KEEP_ALIVE_TEST_PORT + "/", protocols_1.GRAPHQL_SUBSCRIPTIONS);
        var yieldCount = 0;
        client.onmessage = function (message) {
            var parsedMessage = JSON.parse(message.data);
            if (parsedMessage.type === messageTypes_1.SUBSCRIPTION_KEEPALIVE) {
                yieldCount += 1;
                if (yieldCount > 1) {
                    client.close();
                    done();
                }
            }
        };
    });
});
//# sourceMappingURL=tests.js.map