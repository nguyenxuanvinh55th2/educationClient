"use strict";
var websocket_1 = require('websocket');
var messageTypes_1 = require('./messageTypes');
var protocols_1 = require('./protocols');
;
var Server = (function () {
    function Server(options, httpServer) {
        var _this = this;
        var subscriptionManager = options.subscriptionManager, onSubscribe = options.onSubscribe, keepAlive = options.keepAlive;
        if (!subscriptionManager) {
            throw new Error('Must provide `subscriptionManager` to websocket server constructor.');
        }
        this.subscriptionManager = subscriptionManager;
        this.onSubscribe = onSubscribe;
        this.wsServer = new websocket_1.server({
            httpServer: httpServer,
            autoAcceptConnections: false,
        });
        this.wsServer.on('request', function (request) {
            if (request.requestedProtocols.indexOf(protocols_1.GRAPHQL_SUBSCRIPTIONS) === -1) {
                request.reject(400, 'Unsupported protocol.');
                return;
            }
            var connection = request.accept(protocols_1.GRAPHQL_SUBSCRIPTIONS, request.origin);
            if (keepAlive) {
                var keepAliveTimer_1 = setInterval(function () {
                    if (connection && connection.state === 'open') {
                        _this.sendKeepAlive(connection);
                    }
                    else {
                        clearInterval(keepAliveTimer_1);
                    }
                }, keepAlive);
            }
            var connectionSubscriptions = {};
            connection.on('message', _this.onMessage(connection, connectionSubscriptions, request));
            connection.on('close', _this.onClose(connection, connectionSubscriptions));
        });
    }
    Server.prototype.onClose = function (connection, connectionSubscriptions) {
        var _this = this;
        return function () {
            Object.keys(connectionSubscriptions).forEach(function (subId) {
                _this.subscriptionManager.unsubscribe(connectionSubscriptions[subId]);
                delete connectionSubscriptions[subId];
            });
        };
    };
    Server.prototype.onMessage = function (connection, connectionSubscriptions, webSocketRequest) {
        var _this = this;
        return function (message) {
            var parsedMessage;
            try {
                parsedMessage = JSON.parse(message.utf8Data);
            }
            catch (e) {
                _this.sendSubscriptionFail(connection, null, { errors: [{ message: e.message }] });
                return;
            }
            var subId = parsedMessage.id;
            switch (parsedMessage.type) {
                case messageTypes_1.SUBSCRIPTION_START:
                    var baseParams = {
                        query: parsedMessage.query,
                        variables: parsedMessage.variables,
                        operationName: parsedMessage.operationName,
                        context: {},
                        formatResponse: undefined,
                        formatError: undefined,
                        callback: undefined,
                    };
                    var promisedParams = Promise.resolve(baseParams);
                    if (_this.onSubscribe) {
                        promisedParams = Promise.resolve(_this.onSubscribe(parsedMessage, baseParams, webSocketRequest));
                    }
                    if (connectionSubscriptions[subId]) {
                        _this.subscriptionManager.unsubscribe(connectionSubscriptions[subId]);
                        delete connectionSubscriptions[subId];
                    }
                    promisedParams.then(function (params) {
                        params['callback'] = function (errors, data) {
                            _this.sendSubscriptionData(connection, subId, data);
                        };
                        return _this.subscriptionManager.subscribe(params);
                    }).then(function (graphqlSubId) {
                        connectionSubscriptions[subId] = graphqlSubId;
                        _this.sendSubscriptionSuccess(connection, subId);
                    }).catch(function (e) {
                        if (e.errors) {
                            _this.sendSubscriptionFail(connection, subId, { errors: e.errors });
                        }
                        else {
                            _this.sendSubscriptionFail(connection, subId, { errors: [{ message: e.message }] });
                        }
                        return;
                    });
                    break;
                case messageTypes_1.SUBSCRIPTION_END:
                    if (typeof connectionSubscriptions[subId] !== 'undefined') {
                        _this.subscriptionManager.unsubscribe(connectionSubscriptions[subId]);
                        delete connectionSubscriptions[subId];
                    }
                    break;
                default:
                    _this.sendSubscriptionFail(connection, subId, {
                        errors: [{
                                message: 'Invalid message type. Message type must be `subscription_start` or `subscription_end`.'
                            }]
                    });
            }
        };
    };
    Server.prototype.sendSubscriptionData = function (connection, subId, payload) {
        var message = {
            type: messageTypes_1.SUBSCRIPTION_DATA,
            id: subId,
            payload: payload,
        };
        connection.sendUTF(JSON.stringify(message));
    };
    Server.prototype.sendSubscriptionFail = function (connection, subId, payload) {
        var message = {
            type: messageTypes_1.SUBSCRIPTION_FAIL,
            id: subId,
            payload: payload,
        };
        connection.sendUTF(JSON.stringify(message));
    };
    Server.prototype.sendSubscriptionSuccess = function (connection, subId) {
        var message = {
            type: messageTypes_1.SUBSCRIPTION_SUCCESS,
            id: subId,
        };
        connection.sendUTF(JSON.stringify(message));
    };
    Server.prototype.sendKeepAlive = function (connection) {
        var message = {
            type: messageTypes_1.SUBSCRIPTION_KEEPALIVE,
        };
        connection.sendUTF(JSON.stringify(message));
    };
    return Server;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Server;
//# sourceMappingURL=server.js.map