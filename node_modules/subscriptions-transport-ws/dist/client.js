"use strict";
var websocket = require('websocket');
var W3CWebSocket = websocket['w3cwebsocket'];
var Backoff = require('backo2');
var messageTypes_1 = require('./messageTypes');
var protocols_1 = require('./protocols');
var isString = require('lodash.isstring');
var isObject = require('lodash.isobject');
var DEFAULT_SUBSCRIPTION_TIMEOUT = 5000;
var Client = (function () {
    function Client(url, options) {
        var _a = (options || {}), _b = _a.timeout, timeout = _b === void 0 ? DEFAULT_SUBSCRIPTION_TIMEOUT : _b, _c = _a.reconnect, reconnect = _c === void 0 ? false : _c, _d = _a.reconnectionAttempts, reconnectionAttempts = _d === void 0 ? Infinity : _d;
        this.url = url;
        this.subscriptions = {};
        this.maxId = 0;
        this.subscriptionTimeout = timeout;
        this.waitingSubscriptions = {};
        this.unsentMessagesQueue = [];
        this.reconnect = reconnect;
        this.reconnectSubscriptions = {};
        this.reconnecting = false;
        this.reconnectionAttempts = reconnectionAttempts;
        this.backoff = new Backoff({ jitter: 0.5 });
        this.connect();
    }
    Client.prototype.subscribe = function (options, handler) {
        var _this = this;
        var query = options.query, variables = options.variables, operationName = options.operationName, context = options.context;
        if (!query) {
            throw new Error('Must provide `query` to subscribe.');
        }
        if (!handler) {
            throw new Error('Must provide `handler` to subscribe.');
        }
        if (!isString(query) ||
            (operationName && !isString(operationName)) ||
            (variables && !isObject(variables))) {
            throw new Error('Incorrect option types to subscribe. `subscription` must be a string,' +
                '`operationName` must be a string, and `variables` must be an object.');
        }
        var subId = this.generateSubscriptionId();
        var message = Object.assign(options, { type: messageTypes_1.SUBSCRIPTION_START, id: subId });
        this.sendMessage(message);
        this.subscriptions[subId] = { options: options, handler: handler };
        this.waitingSubscriptions[subId] = true;
        setTimeout(function () {
            if (_this.waitingSubscriptions[subId]) {
                handler([new Error('Subscription timed out - no response from server')]);
                _this.unsubscribe(subId);
            }
        }, this.subscriptionTimeout);
        return subId;
    };
    Client.prototype.unsubscribe = function (id) {
        delete this.subscriptions[id];
        delete this.waitingSubscriptions[id];
        var message = { id: id, type: messageTypes_1.SUBSCRIPTION_END };
        this.sendMessage(message);
    };
    Client.prototype.unsubscribeAll = function () {
        var _this = this;
        Object.keys(this.subscriptions).forEach(function (subId) {
            _this.unsubscribe(parseInt(subId));
        });
    };
    Client.prototype.sendMessage = function (message) {
        switch (this.client.readyState) {
            case this.client.OPEN:
                this.client.send(JSON.stringify(message));
                break;
            case this.client.CONNECTING:
                this.unsentMessagesQueue.push(message);
                break;
            case this.client.CLOSING:
            case this.client.CLOSED:
            default:
                if (!this.reconnecting) {
                    throw new Error('Client is not connected to a websocket.');
                }
        }
    };
    Client.prototype.generateSubscriptionId = function () {
        var id = this.maxId;
        this.maxId += 1;
        return id;
    };
    Client.prototype.formatErrors = function (errors) {
        if (Array.isArray(errors)) {
            return errors;
        }
        if (errors && errors.message) {
            return [errors];
        }
        return [{ message: 'Unknown error' }];
    };
    Client.prototype.tryReconnect = function () {
        var _this = this;
        if (!this.reconnect) {
            return;
        }
        if (this.backoff.attempts > this.reconnectionAttempts) {
            return;
        }
        if (!this.reconnecting) {
            this.reconnectSubscriptions = this.subscriptions;
            this.subscriptions = {};
            this.waitingSubscriptions = {};
            this.reconnecting = true;
        }
        var delay = this.backoff.duration();
        setTimeout(function () {
            _this.connect();
        }, delay);
    };
    Client.prototype.connect = function () {
        var _this = this;
        this.client = new W3CWebSocket(this.url, protocols_1.GRAPHQL_SUBSCRIPTIONS);
        this.client.onopen = function () {
            _this.reconnecting = false;
            _this.backoff.reset();
            Object.keys(_this.reconnectSubscriptions).forEach(function (key) {
                var _a = _this.reconnectSubscriptions[key], options = _a.options, handler = _a.handler;
                _this.subscribe(options, handler);
            });
            _this.unsentMessagesQueue.forEach(function (message) {
                _this.client.send(JSON.stringify(message));
            });
            _this.unsentMessagesQueue = [];
        };
        this.client.onclose = function () {
            _this.tryReconnect();
        };
        this.client.onmessage = function (message) {
            var parsedMessage;
            try {
                parsedMessage = JSON.parse(message.data);
            }
            catch (e) {
                throw new Error('Message must be JSON-parseable.');
            }
            var subId = parsedMessage.id;
            if (parsedMessage.type !== messageTypes_1.SUBSCRIPTION_KEEPALIVE && !_this.subscriptions[subId]) {
                _this.unsubscribe(subId);
                return;
            }
            switch (parsedMessage.type) {
                case messageTypes_1.SUBSCRIPTION_SUCCESS:
                    delete _this.waitingSubscriptions[subId];
                    break;
                case messageTypes_1.SUBSCRIPTION_FAIL:
                    _this.subscriptions[subId].handler(_this.formatErrors(parsedMessage.payload.errors), null);
                    delete _this.subscriptions[subId];
                    delete _this.waitingSubscriptions[subId];
                    break;
                case messageTypes_1.SUBSCRIPTION_DATA:
                    if (parsedMessage.payload.data && !parsedMessage.payload.errors) {
                        _this.subscriptions[subId].handler(null, parsedMessage.payload.data);
                    }
                    else {
                        _this.subscriptions[subId].handler(_this.formatErrors(parsedMessage.payload.errors), null);
                    }
                    break;
                case messageTypes_1.SUBSCRIPTION_KEEPALIVE:
                    break;
                default:
                    throw new Error('Invalid message type - must be of type `subscription_start`, `subscription_data` or `subscription_keepalive`.');
            }
        };
    };
    return Client;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Client;
;
//# sourceMappingURL=client.js.map